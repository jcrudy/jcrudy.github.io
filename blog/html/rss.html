<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>A Fistful of Data</title>
        <link>http://jcrudy.github.io/blog/html/</link>
        <description>data wrangling and other cowboy stuff</description>
        <language>en-us</language>
        <pubDate>Fri, 07 Feb 2014 00:00:00 -0800</pubDate>
        
        <item>
            <link>http://jcrudy.github.io/blog/html/2014/02/07/boosting_with_mars.html</link>
            <guid>http://jcrudy.github.io/blog/html/2014/02/07/boosting_with_mars.html</guid>
            <title><![CDATA[Boosting with MARS]]></title>
            <description><![CDATA[<div class="section" id="boosting-with-mars">
<h1>Boosting with MARS</h1>
<p>Someone wrote me a few months ago asking for advice.  He was an R user who wanted to combine the adaboost algorithm with MARS and was starting to look outside the R community.  As a recovering (and occasionally relapsing) R user myself, I was only too happy to look into the matter.  As it turns out, it’s actually not that hard to do with a combination of scikit-learn and py-earth.  I now recount the adventure in detail.</p>
<p>Let it be known that this fine community member was interested in MARS not for regression, as is its usual role, but for classification.  This first challenge is easily accomplished using the Pipeline class, as follows.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LogisticRegression</span>
<span class="kn">from</span> <span class="nn">pyearth</span> <span class="kn">import</span> <span class="n">Earth</span>

<span class="n">model</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">([(</span><span class="s">'earth'</span><span class="p">,</span><span class="n">Earth</span><span class="p">()),(</span><span class="s">'log'</span><span class="p">,</span><span class="n">LogisticRegression</span><span class="p">())])</span>
</pre></div>
</div>
<p>The above construction is equivalent to using the earth package from R with <cite>glm=list(family=binomial)</cite>.</p>
<p>Adaboost requires a classifier that can handle weighted samples.  The <cite>Earth</cite> class satisfies this requirement.  <cite>LogisticRegression</cite> does not, but we can replace it with <cite>SGDClassifier</cite> using <cite>loss=’log’</cite> to get an equivalent Pipeline that can handle sample weights.  Or, at least, it seems like it could.  As it turns out, though, the <cite>Pipeline</cite> class doesn’t actually know how to act as a base estimator in <cite>AdaBoostClassifier</cite>.  When you try to fit the resulting model, you get an error.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span> <span class="nn">pyearth</span> <span class="kn">import</span> <span class="n">Earth</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model.stochastic_gradient</span> <span class="kn">import</span> <span class="n">SGDClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_classification</span>
<span class="kn">from</span> <span class="nn">sklearn.ensemble.weight_boosting</span> <span class="kn">import</span> <span class="n">AdaBoostClassifier</span>


<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_classification</span><span class="p">()</span>
<span class="n">classifier</span> <span class="o">=</span> <span class="n">Pipeline</span><span class="p">([(</span><span class="s">'earth'</span><span class="p">,</span><span class="n">Earth</span><span class="p">()),(</span><span class="s">'log'</span><span class="p">,</span><span class="n">SGDClassifier</span><span class="p">(</span><span class="n">loss</span><span class="o">=</span><span class="s">'log'</span><span class="p">))])</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">AdaBoostClassifier</span><span class="p">(</span><span class="n">base_estimator</span><span class="o">=</span><span class="n">classifier</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>This code produces <cite>TypeError: base_estimator must be a subclass of ClassifierMixin</cite>.  You can get to the next error by making a special subclass of <cite>Pipeline</cite> like so.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">from</span> <span class="nn">sklearn.pipeline</span> <span class="kn">import</span> <span class="n">Pipeline</span>
<span class="kn">from</span> <span class="nn">pyearth</span> <span class="kn">import</span> <span class="n">Earth</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model.stochastic_gradient</span> <span class="kn">import</span> <span class="n">SGDClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_classification</span>
<span class="kn">from</span> <span class="nn">sklearn.ensemble.weight_boosting</span> <span class="kn">import</span> <span class="n">AdaBoostClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.base</span> <span class="kn">import</span> <span class="n">ClassifierMixin</span>

<span class="k">class</span> <span class="nc">ClassifierPipeline</span><span class="p">(</span><span class="n">Pipeline</span><span class="p">,</span> <span class="n">ClassifierMixin</span><span class="p">):</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">classes_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">steps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">classes_</span>

<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_classification</span><span class="p">()</span>
<span class="n">classifier</span> <span class="o">=</span> <span class="n">ClassifierPipeline</span><span class="p">([(</span><span class="s">'earth'</span><span class="p">,</span><span class="n">Earth</span><span class="p">()),(</span><span class="s">'log'</span><span class="p">,</span><span class="n">SGDClassifier</span><span class="p">(</span><span class="n">loss</span><span class="o">=</span><span class="s">'log'</span><span class="p">))])</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">AdaBoostClassifier</span><span class="p">(</span><span class="n">base_estimator</span><span class="o">=</span><span class="n">classifier</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>Now this code gives <cite>ValueError: need more than 1 value to unpack</cite>.  That’s somewhat more inscrutible.  To get around this one you actually have to rewrite part of the <cite>Pipeline</cite> class itself.  I posted a modified <cite>Pipeline</cite> as a <a class="reference external" href="https://gist.github.com/jcrudy/7493865#file-pipeline-py">gist</a>.  You can patch it in and use it like this.</p>
<div class="code python highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">pipeline</span> <span class="kn">as</span> <span class="nn">alt_pipeline</span>
<span class="kn">from</span> <span class="nn">sklearn.base</span> <span class="kn">import</span> <span class="n">ClassifierMixin</span>
<span class="kn">from</span> <span class="nn">pyearth</span> <span class="kn">import</span> <span class="n">Earth</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model.stochastic_gradient</span> <span class="kn">import</span> <span class="n">SGDClassifier</span>
<span class="kn">from</span> <span class="nn">sklearn.datasets</span> <span class="kn">import</span> <span class="n">make_classification</span>
<span class="kn">from</span> <span class="nn">sklearn.ensemble.weight_boosting</span> <span class="kn">import</span> <span class="n">AdaBoostClassifier</span>

<span class="k">class</span> <span class="nc">ClassifierPipeline</span><span class="p">(</span><span class="n">alt_pipeline</span><span class="o">.</span><span class="n">Pipeline</span><span class="p">,</span> <span class="n">ClassifierMixin</span><span class="p">):</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">classes_</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">steps</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">classes_</span>
<span class="n">X</span><span class="p">,</span> <span class="n">y</span> <span class="o">=</span> <span class="n">make_classification</span><span class="p">()</span>
<span class="n">classifier</span> <span class="o">=</span> <span class="n">ClassifierPipeline</span><span class="p">([(</span><span class="s">'earth'</span><span class="p">,</span><span class="n">Earth</span><span class="p">()),(</span><span class="s">'log'</span><span class="p">,</span><span class="n">SGDClassifier</span><span class="p">(</span><span class="n">loss</span><span class="o">=</span><span class="s">'log'</span><span class="p">))])</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">AdaBoostClassifier</span><span class="p">(</span><span class="n">base_estimator</span><span class="o">=</span><span class="n">classifier</span><span class="p">)</span>
<span class="n">model</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</pre></div>
</div>
<p>So that’s how you use AdaBoost with MARS in Python.</p>
</div>]]></description>
            <category><![CDATA[ Python ]]></category>
             <pubDate>Fri, 07 Feb 2014 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://jcrudy.github.io/blog/html/2013/12/08/introduction_to_iscala.html</link>
            <guid>http://jcrudy.github.io/blog/html/2013/12/08/introduction_to_iscala.html</guid>
            <title><![CDATA[Introduction to IScala]]></title>
            <description><![CDATA[<div class="section" id="introduction-to-iscala">
<h1>Introduction to IScala</h1>
<p>Python is an amazingly productive glue language.  It’s become popular among data scientists over the past several years, partially because of great libraries like numpy, scipy, pandas, scikit-learn, statsmodels, etc., and partially because so much of data science consists simply of gluing things together.  There is a part of my life, though, that consists of actually implementing machine learning algorithms.  Python does not make that part easy.  In order to write efficient numerical code for Python, you need to move the majority of the computation out of Python and into statically typed, compiled code.  The best solution I’ve found is Cython, which compiles a Python-like language to C while taking care of the Python C api for you.  I wrote py-earth in Cython and am fairly happy with the result.  However, Cython is still a (really fantastic) hack.  Getting good performance out of Cython code requires knowledge of both C and the internals of Python, and most of the good stuff about Python - passing around functions, object-oriented design, readability - is lost when you start to really optimize.  If you want to combine concurrency with objects, you actually have to start passing pointers around.</p>
<p>I guess what I’m saying is I want to branch out a little.  I’d like to find a language where I can be productive both as a scientific user and as a scientific developer, something modern, new but not too new, mainstream but with just a bit of an edge.  Tall.  Anyway, it seems like there are two new languages out there vying for my affection.  I chose Scala over Julia for two reasons.  Firstly, Scala is a general purpose programming language.  While statisticians and academic scientists are very happy to use single purpose tools like R to do their analyses, data scientists need the ability to actually write software and integrate their analyses into larger projects.  Secondly, Scala is implemented on the JVM and compatible with Java.  That means I can use any Java library from within Scala and use Scala to write map-reduce queries for an Hadoop cluster without using the streaming interface.</p>
<p>So I’m exploring the Scala ecosystem and learning the language (which so far I think is fantastic).  My goal is to do some data analyses and implement one or two non-trivial algorithms in Scala.  But one step at a time.  Today I want to share <a class="reference external" href="https://github.com/mattpap/IScala">IScala</a>, which is basically just IPython with a Scala backend.  Although I actually rarely use IPython, I know a lot of people do and I suspect that Scala adoption will require the existence of a useful IPython replacement.</p>
<div class="section" id="installing">
<h2>Installing</h2>
<p>The IScala readme file lists several installation options.  The one that worked for me was as follows.  First, download the <a class="reference external" href="https://github.com/mattpap/IScala/releases">latest tarball</a> and unpack it somewhere.  I put it directly in my home directory.  Then create a scala profile for ipython:</p>
<div class="highlight-none"><div class="highlight"><pre>$ipython profile create scala
[ProfileCreate] Generating default config file: u'/Users/jason/.ipython/profile_scala/ipython_config.py'
[ProfileCreate] Generating default config file: u'/Users/jason/.ipython/profile_scala/ipython_qtconsole_config.py'
[ProfileCreate] Generating default config file: u'/Users/jason/.ipython/profile_scala/ipython_notebook_config.py'
[ProfileCreate] Generating default config file: u'/Users/jason/.ipython/profile_scala/ipython_nbconvert_config.py'
</pre></div>
</div>
<p>The output above tells you the location of the ipython_config.py file.  The next step is to edit ipython_config.py to tell IPython about the IScala kernel, as below:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="c"># Configuration file for ipython.</span>
<span class="n">c</span> <span class="o">=</span> <span class="n">get_config</span><span class="p">()</span>

<span class="c"># Use the IScala kernel</span>
<span class="hll"><span class="n">c</span><span class="o">.</span><span class="n">KernelManager</span><span class="o">.</span><span class="n">kernel_cmd</span> <span class="o">=</span> <span class="p">[</span><span class="s">&quot;java&quot;</span><span class="p">,</span> <span class="s">&quot;-jar&quot;</span><span class="p">,</span>
</span><span class="hll">                              <span class="s">&quot;$ISCALA_PATH/lib/IScala.jar&quot;</span><span class="p">,</span>
</span><span class="hll">                              <span class="s">&quot;--profile&quot;</span><span class="p">,</span>
</span><span class="hll">                              <span class="s">&quot;{connection_file}&quot;</span><span class="p">,</span>
</span><span class="hll">                              <span class="s">&quot;--parent&quot;</span><span class="p">]</span>
</span></pre></div>
</div>
<p>After you get this working, with $ISCALA_PATH replaced by the path to wherever you put the unpacked IScala download, you should be able to run IScala by saying:</p>
<div class="highlight-none"><div class="highlight"><pre>$ipython notebook --profile scala
</pre></div>
</div>
<p>or similarly for console or qtconsole.</p>
</div>
<div class="section" id="taking-it-for-a-spin">
<h2>Taking it for a spin</h2>
<p>I’m going to try generating a random matrix with a standard normal distribution.  The first thing I’ll need to do is import breeze.  My first attempt failed.</p>
<div class="iscala container">
<div class="code scala highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">breeze.linalg._</span>
<span class="kn">import</span> <span class="nn">breeze.stats.distributions._</span>
</pre></div>
</div>
<div class="highlight-python"><pre>&lt;console&gt;:7: error: not found: value breeze
       import breeze.linalg._
              ^
&lt;console&gt;:8: error: not found: value breeze
       import breeze.stats.distributions._
              ^</pre>
</div>
</div>
<p>I needed to tell sbt where to find breeze.  It turns out you can use IPython magic to talk to sbt like this.</p>
<div class="iscala container">
<div class="code scala highlight-python"><pre>%resolvers += &quot;ScalaNLP Maven2&quot; at &quot;http://repo.scalanlp.org/repo&quot;

%resolvers += &quot;Scala Tools Snapshots&quot; at &quot;http://scala-tools.org/repo-snapshots/&quot;

%resolvers += &quot;Typesafe Repository&quot; at &quot;http://repo.typesafe.com/typesafe/releases/&quot;

%resolvers += &quot;Sonatype Snapshots&quot; at &quot;https://oss.sonatype.org/content/repositories/snapshots&quot;

%libraryDependencies += &quot;org.scalanlp&quot; %% &quot;breeze&quot; % &quot;0.6-SNAPSHOT&quot;

%update</pre>
</div>
<div class="highlight-python"><pre>[info] Resolving org.scalanlp#breeze_2.10;0.6-SNAPSHOT ...
[info] Resolving org.scala-lang#scala-library;2.10.3 ...
[info] Resolving org.scalanlp#breeze-macros_2.10;0.1 ...
[info] Resolving org.scala-lang#scala-reflect;2.10.3 ...
[info] Resolving com.thoughtworks.paranamer#paranamer;2.2 ...
[info] Resolving com.github.fommil.netlib#all;1.1.2 ...
[info] Resolving net.sourceforge.f2j#arpack_combined_all;0.1 ...
[info] Resolving com.github.fommil.netlib#core;1.1.2 ...
[info] Resolving com.github.fommil.netlib#netlib-native_ref-osx-x86_64;1.1 ...
[info] Resolving com.github.fommil.netlib#native_ref-java;1.1 ...
[info] Resolving com.github.fommil#jniloader;1.1 ...
[info] Resolving com.github.fommil.netlib#netlib-native_ref-linux-x86_64;1.1 ...
[info] Resolving com.github.fommil.netlib#netlib-native_ref-linux-i686;1.1 ...
[info] Resolving com.github.fommil.netlib#netlib-native_ref-win-x86_64;1.1 ...
[info] Resolving com.github.fommil.netlib#netlib-native_ref-win-i686;1.1 ...
[info] Resolving com.github.fommil.netlib#netlib-native_ref-linux-armhf;1.1 ...
[info] Resolving com.github.fommil.netlib#netlib-native_system-osx-x86_64;1.1 ...
[info] Resolving com.github.fommil.netlib#native_system-java;1.1 ...
[info] Resolving com.github.fommil.netlib#netlib-native_system-linux-x86_64;1.1 ...
[info] Resolving com.github.fommil.netlib#netlib-native_system-linux-i686;1.1 ...
[info] Resolving com.github.fommil.netlib#netlib-native_system-linux-armhf;1.1 ...
[info] Resolving com.github.fommil.netlib#netlib-native_system-win-x86_64;1.1 ...
[info] Resolving com.github.fommil.netlib#netlib-native_system-win-i686;1.1 ...
[info] Resolving org.scalanlp#lpsolve;5.5.2-SNAPSHOT ...
[info] Resolving net.sf.opencsv#opencsv;2.3 ...
[info] Resolving com.github.rwl#jtransforms;2.4.0 ...
[info] Resolving junit#junit;4.8.2 ...
[info] Resolving org.apache.commons#commons-math3;3.2 ...
[info] Resolving com.typesafe#scalalogging-slf4j_2.10;1.0.1 ...
[info] Resolving org.slf4j#slf4j-api;1.7.2 ...</pre>
</div>
<div class="code scala highlight-python"><div class="highlight"><pre><span class="kn">import</span> <span class="nn">breeze.linalg._</span>
<span class="kn">import</span> <span class="nn">breeze.stats.distributions._</span>
</pre></div>
</div>
</div>
<p>That worked!  I can now generate my random matrix like this:</p>
<div class="iscala container">
<div class="code scala highlight-python"><pre>val x = DenseMatrix.fill(10,10)(Gaussian(0,1).draw())</pre>
</div>
<div class="highlight-python"><pre>0.4695170376110142   0.5086639312405534    ... (10 total)
0.2604624080687952   -0.03678938632256435  ...
-1.0528337756159565  0.10082649287241126   ...
-0.550492849679171   -0.5761878622563654   ...
-0.9817603551889219  0.7958446618784706    ...
-1.0001995322763473  -1.2424889465651479   ...
-0.5879313146878662  1.206569217055404     ...
1.890300548243616    -0.30273380341887257  ...
0.24792587873136573  -0.04329745764599858  ...
1.5057194826425122   0.9516921598743895    ...</pre>
</div>
</div>
</div>
<div class="section" id="final-thoughts">
<h2>Final thoughts</h2>
<p>So IScala is up and running.  There doesn’t yet appear to be any support for displaying plots in the notebook, and it is a little annoying that I have to %update to add new dependencies (which causes the Scala process to restart and all existing objects to be lost from memory).  However, IScala is a new project and these are minor issues.  During the process I discovered something disconcerting about the Scala ecosystem, however.  There is not currently a Scala equivalent of numpy.  That is, there is no basic structure that everyone agrees is the standard backend array type.  Instead, there are several competing packages (of which <a class="reference external" href="http://www.scalanlp.org">breeze</a> is just one) that accomplish this extremely basic function.  I need to decide which one I want to develop on.</p>
</div>
</div>]]></description>
             <pubDate>Sun, 08 Dec 2013 00:00:00 -0800</pubDate>
        </item>
    
        <item>
            <link>http://jcrudy.github.io/blog/html/2013/12/02/blogstart.html</link>
            <guid>http://jcrudy.github.io/blog/html/2013/12/02/blogstart.html</guid>
            <title><![CDATA[Blogstart]]></title>
            <description><![CDATA[<div class="section" id="blogstart">
<h1>Blogstart</h1>
<p>Once in a great while a new blog is born, and today these rusty tubes are graced with a sparkling new presence.  It’s a little rough right now, but greatness can grow from meek beginnings.  Let us take a moment to remember some of the great weblogs of the past, to whose unfathomable heights this humble site may hope one day to spy on the horizon.  <a class="reference external" href="http://jakevdp.github.io">Pythonic Perambulations</a>, <a class="reference external" href="http://twiecki.github.io">While My MCMC Gently Samples</a>, and all the rest, may I follow in your wise footsteps.  This blog will be much in the spirit of these gentle giants.  It will concern my work and particularly my Python code.  It will contain short pieces of opinion, medium length demonstrations of technology, and longer analyses of data.  It will not be limited to Python or even to programming and statistics, but will tend to concern those topics more than any other.  At least that is my intention.</p>
<div class="section" id="blog-rules">
<h2>Blog Rules <a class="footnote-reference" href="#f1" id="id1">[1]</a></h2>
<p>Every blog needs rules.  Here are some.</p>
<ol class="arabic simple">
<li>Trust no one.</li>
<li>Posts occur at least once per month.</li>
<li>Nothing is final.  If you want to see revision history, the <a class="reference external" href="https://github.com/jcrudy/jcrudy.github.io">blog is hosted on github</a>.</li>
</ol>
</div>
<div class="section" id="blog-implementation">
<h2>Blog Implementation</h2>
<p>This blog, at least at the moment, is constructed using the <a class="reference external" href="http://tinkerer.me">Tinkerer</a> static blogging framework.  Why Tinkerer you ask?  When choosing a static blogging framework I considered the following options: Octopress, Jekyll, Hyde, Pelican, and Tinkerer.  I ruled out Octopress and Jekyll easily enough.  Although they’re both popular, they’re not Python and it would therefore be hard for me to read and understand the source code should the unthinkable occur.  Of the three remaining, I chose Tinkerer because it is based on Sphinx.  Sphinx is a mature and well supported Python tool for generating documentation.  Its main selling point for me is the easy support for math, syntax-highlighted code, bibtex, footnotes, and basically every other imaginable feature of a document via an impressive collection of plugins.  The downside of Tinkerer is that it’s relatively small userbase has produced very few nice looking themes.  However, I’ve decided theming is a secondary consideration for now.  Perhaps I can help to remedy the situation in the near future.</p>
<table class="docutils footnote" frame="void" id="f1" rules="none">
<colgroup><col class="label"/><col/></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>As with any ordered set of rules, the zeroeth rule is that there are no rules.</td></tr>
</tbody>
</table>
</div>
</div>]]></description>
             <pubDate>Mon, 02 Dec 2013 00:00:00 -0800</pubDate>
        </item>
    
    </channel>
</rss>